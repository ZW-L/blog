(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{444:function(t,v,_){"use strict";_.r(v);var e=_(25),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),_("ul",[_("li",[t._v("提供了一系列的语法糖，看起来更像 OOP 的方式")]),t._v(" "),_("li",[_("code",[t._v("class")]),t._v("：声明一个类")]),t._v(" "),_("li",[_("code",[t._v("extends")]),t._v("：声明类的继承")]),t._v(" "),_("li",[_("code",[t._v("constructor()")]),t._v("：函数定义构造方法")]),t._v(" "),_("li",[_("code",[t._v("super()")]),t._v("：调用父类的构造函数")]),t._v(" "),_("li",[_("code",[t._v("static")]),t._v("：声明类的静态方法(即构造函数的方法)")]),t._v(" "),_("li",[_("code",[t._v("new.target")]),t._v("： 访问创建实例时调用的构造函数")])]),t._v(" "),_("h2",{attrs:{id:"继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),_("ul",[_("li",[t._v("使用 "),_("code",[t._v("class")]),t._v(" 语法实现继承时，子类必须要在 "),_("code",[t._v("constructor()")]),t._v(" 函数内调用父类的构造函数("),_("code",[t._v("super()")]),t._v(")，而且在这之前都不能访问 "),_("code",[t._v("this")])]),t._v(" "),_("li",[_("code",[t._v("super")]),t._v(" 关键字\n"),_("ul",[_("li",[t._v("调用变量时，在普通方法中指向父类的原型，在静态方法中指向父类")]),t._v(" "),_("li",[t._v("调用方法时，在普通方法中指向父类的原型，在静态方法中指向父类，但是 "),_("code",[t._v("this")]),t._v(" 绑定的是子类")])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);